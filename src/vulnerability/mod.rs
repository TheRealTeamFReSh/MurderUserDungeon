use crate::apartment::{
    BasicAnimationComponent, InteractableComponent, InteractableType, NPC_Z, PLAYER_SPRITE_SCALE,
};
use crate::misc::game_over::{GameOverData, GameOverReason};
use crate::states::GameState;
use bevy::prelude::*;
use serde::Deserialize;
use std::collections::HashMap;

pub const NPC_FRAME_TIME: f32 = 0.4;

pub struct VulnerabilityPlugin;

impl Plugin for VulnerabilityPlugin {
    fn build(&self, app: &mut AppBuilder) {
        let mut timed_vulnerabilities: HashMap<TimedVulnerabilityType, Timer> = HashMap::new();
        timed_vulnerabilities.insert(
            TimedVulnerabilityType::ConsoleDoorLeftOpen,
            Timer::from_seconds(8.0, false),
        );

        let mut bool_vulnerabilities: HashMap<BoolVulnerabilityType, bool> = HashMap::new();
        bool_vulnerabilities.insert(BoolVulnerabilityType::BedDoorLeftOpen, false);
        bool_vulnerabilities.insert(BoolVulnerabilityType::PeeDoorLeftOpen, false);
        bool_vulnerabilities.insert(BoolVulnerabilityType::TooManyRageQuit, false);
        bool_vulnerabilities.insert(BoolVulnerabilityType::TicTacToeLosing, false);
        bool_vulnerabilities.insert(BoolVulnerabilityType::LabyrinthLosing, false);

        app.insert_resource(VulnerabilityResource {
            timed_vulnerabilities,
            bool_vulnerabilities,
            vulnerability_per_frame: 1.0,
        })
        .add_system(update_timed_vulnerabilities_system.system())
        .add_system(update_booled_vulnerabilities_system.system());
    }
}

#[derive(Deserialize, Hash, Clone, Debug, PartialEq, Eq)]
pub enum TimedVulnerabilityType {
    ConsoleDoorLeftOpen,
}

#[derive(Deserialize, Hash, Clone, Debug, PartialEq, Eq)]
pub enum BoolVulnerabilityType {
    BedDoorLeftOpen,
    PeeDoorLeftOpen,
    TooManyRageQuit,
    TicTacToeLosing,
    LabyrinthLosing,
}

#[derive(Debug)]
pub struct VulnerabilityResource {
    pub vulnerability_per_frame: f32,
    pub timed_vulnerabilities: HashMap<TimedVulnerabilityType, Timer>,
    pub bool_vulnerabilities: HashMap<BoolVulnerabilityType, bool>,
}

#[derive(Debug)]
pub struct VulnerabilityData {
    pub vulnerability: f32,
    pub game_over_threshold: f32,
}

pub fn update_timed_vulnerabilities_system(
    mut commands: Commands,
    interactables_query: Query<&InteractableComponent>,
    mut vulnerability_resource: ResMut<VulnerabilityResource>,
    mut app_state: ResMut<State<GameState>>,
    mut texture_atlases: ResMut<Assets<TextureAtlas>>,
    time: Res<Time>,
    asset_server: Res<AssetServer>,
    audio: Res<Audio>,
    mut go_data: ResMut<GameOverData>,
) {
    for (v_type, v_timer) in vulnerability_resource.timed_vulnerabilities.iter_mut() {
        match v_type {
            TimedVulnerabilityType::ConsoleDoorLeftOpen => {
                for interactable_component in interactables_query.iter() {
                    if app_state.current() == &GameState::ConsoleOpenedState
                        && InteractableType::OpenDoor == interactable_component.interactable_type
                    {
                        v_timer.tick(time.delta());
                    } else if app_state.current() == &GameState::MainGame
                        && InteractableType::ClosedDoor == interactable_component.interactable_type
                    {
                        v_timer.reset();
                    }
                }

                if v_timer.just_finished() {
                    v_timer.reset();
                    v_timer.pause();
                    spawn_npc(
                        "textures/npcs/npc_1_forward_spritesheet.png",
                        Vec2::new(-215.0, -72.0),
                        &mut commands,
                        &asset_server,
                        &mut texture_atlases,
                    );
                    if app_state.current() == &GameState::ConsoleOpenedState {
                        go_data.reason = Some(GameOverReason::DoorLeftOpen);
                        app_state.set(GameState::GameOverState).unwrap();
                        info!("Console closed");
                    }
                    audio.play(asset_server.load("audio/dramatic_scare.mp3"));
                }
            }
        }
    }
}

pub fn update_booled_vulnerabilities_system(
    vuln_res: Res<VulnerabilityResource>,
    mut app_state: ResMut<State<GameState>>,
    mut go_data: ResMut<GameOverData>,
) {
    if *vuln_res
        .bool_vulnerabilities
        .get(&BoolVulnerabilityType::TooManyRageQuit)
        .unwrap()
        && app_state.current() == &GameState::ConsoleOpenedState
    {
        go_data.reason = Some(GameOverReason::TooManyRageQuit);
        app_state.set(GameState::GameOverState).unwrap();
    }

    if *vuln_res
        .bool_vulnerabilities
        .get(&BoolVulnerabilityType::TicTacToeLosing)
        .unwrap()
        && app_state.current() == &GameState::ConsoleOpenedState
    {
        go_data.reason = Some(GameOverReason::TicTacToeLosing);
        app_state.set(GameState::GameOverState).unwrap();
    }

    if *vuln_res
        .bool_vulnerabilities
        .get(&BoolVulnerabilityType::LabyrinthLosing)
        .unwrap()
        && app_state.current() == &GameState::ConsoleOpenedState
    {
        go_data.reason = Some(GameOverReason::LabyrinthLosing);
        app_state.set(GameState::GameOverState).unwrap();
    }
}

pub fn spawn_npc(
    npc_sprite_path: &str,
    position: Vec2,
    commands: &mut Commands,
    asset_server: &AssetServer,
    texture_atlases: &mut Assets<TextureAtlas>,
) {
    let texture_handle = asset_server.load(npc_sprite_path);
    let texture_atlas = TextureAtlas::from_grid(texture_handle, Vec2::new(32.0, 46.0), 6, 1);
    let texture_atlas_handle = texture_atlases.add(texture_atlas);

    let sprite_transform = Transform {
        translation: Vec3::new(position.x, position.y, NPC_Z),
        scale: Vec3::new(PLAYER_SPRITE_SCALE, PLAYER_SPRITE_SCALE, 0.0),
        ..Default::default()
    };

    commands
        .spawn()
        .insert(BasicAnimationComponent)
        .insert(Timer::from_seconds(NPC_FRAME_TIME, true))
        .insert_bundle(SpriteSheetBundle {
            texture_atlas: texture_atlas_handle,
            transform: sprite_transform,
            ..Default::default()
        })
        .insert(Name::new("NPC"));
}
