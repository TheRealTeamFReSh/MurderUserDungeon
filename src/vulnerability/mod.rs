use crate::apartment::{
    despawn_hallway_cover,
    door::{spawn_closed_door, spawn_open_door},
    phone::{PizzaDeliveryResource, PizzaDeliveryStatus},
    spawn_hallway_cover, BasicAnimationComponent, HallwayCoverComponent, InteractableComponent,
    InteractableType, InteractablesResource, NPC_Z, PLAYER_SPRITE_SCALE,
};
use crate::misc::{
    day_cycle::DayCycleResource,
    game_over::{GameOverData, GameOverReason},
};
use crate::npcs::NPCsResource;
use crate::states::GameState;
use bevy::prelude::*;
use rand::Rng;
use serde::Deserialize;
use std::collections::HashMap;
use std::f32::consts::PI;
use std::time::Duration;

pub const NPC_FRAME_TIME: f32 = 0.4;
pub const DIFFICULTY: f32 = 0.3;
pub const LOCKPICK_CHECK_FREQ: f32 = 5.0;
pub const TIME_TO_LOCKPICK: f32 = 20.0;
pub const LOCKPICK_SEARCH_TIME: f32 = 7.0;

pub struct VulnerabilityPlugin;

impl Plugin for VulnerabilityPlugin {
    fn build(&self, app: &mut AppBuilder) {
        let mut timed_vulnerabilities: HashMap<TimedVulnerabilityType, Timer> = HashMap::new();
        timed_vulnerabilities.insert(
            TimedVulnerabilityType::ConsoleDoorLeftOpen,
            Timer::from_seconds(8.0, false),
        );

        let mut bool_vulnerabilities: HashMap<BoolVulnerabilityType, bool> = HashMap::new();
        bool_vulnerabilities.insert(BoolVulnerabilityType::BedDoorLeftOpen, false);
        bool_vulnerabilities.insert(BoolVulnerabilityType::PeeDoorLeftOpen, false);
        bool_vulnerabilities.insert(BoolVulnerabilityType::TooManyRageQuit, false);
        bool_vulnerabilities.insert(BoolVulnerabilityType::TicTacToeLosing, false);
        bool_vulnerabilities.insert(BoolVulnerabilityType::LabyrinthLosing, false);
        bool_vulnerabilities.insert(BoolVulnerabilityType::LabyrinthWinning, false);

        app.insert_resource(VulnerabilityResource {
            timed_vulnerabilities,
            bool_vulnerabilities,
            vulnerability_per_frame: 1.0,
            at_door: AtDoorType::None,
            vulnerability_factor: 0.0,
            lockpick_timer: Timer::from_seconds(LOCKPICK_CHECK_FREQ, true),
            lockpicking_progress_timer: Timer::from_seconds(TIME_TO_LOCKPICK, true),
            lockpicking_status: LockpickingStatus::None,
            lockpicking_audio_timer: Timer::from_seconds(2.0, true),
            lockpicking_search_timer: Timer::from_seconds(LOCKPICK_SEARCH_TIME, true),
            enemies: vec![String::from("NoobGamer98")], // TODO: remove when enemies are added from labyrinth
            is_hiding: false,
        })
        .add_system_set(
            SystemSet::on_update(GameState::MainGame)
                .with_system(update_timed_vulnerabilities_system.system())
                .with_system(update_vulnerability_factor_system.system())
                .with_system(lockpicking_system.system().after("exit_hiding"))
                .with_system(update_booled_vulnerabilities_system.system()),
        )
        .add_system_set(
            SystemSet::on_update(GameState::ConsoleOpenedState)
                .with_system(update_timed_vulnerabilities_system.system())
                .with_system(update_vulnerability_factor_system.system())
                .with_system(lockpicking_system.system().after("exit_hiding"))
                .with_system(update_booled_vulnerabilities_system.system()),
        )
        .add_system_set(
            SystemSet::on_update(GameState::PlayerEatingState)
                .with_system(update_timed_vulnerabilities_system.system())
                .with_system(update_vulnerability_factor_system.system())
                .with_system(update_booled_vulnerabilities_system.system()),
        )
        .add_system_set(
            SystemSet::on_update(GameState::PlayerOrderingPizzaState)
                .with_system(update_timed_vulnerabilities_system.system())
                .with_system(update_vulnerability_factor_system.system())
                .with_system(update_booled_vulnerabilities_system.system()),
        )
        .add_system_set(
            SystemSet::on_update(GameState::PeepholeOpenedState)
                .with_system(update_timed_vulnerabilities_system.system())
                .with_system(update_vulnerability_factor_system.system())
                .with_system(lockpicking_system.system().after("exit_hiding"))
                .with_system(update_booled_vulnerabilities_system.system()),
        )
        .add_system_set(
            SystemSet::on_update(GameState::PlayerHidingState)
                .with_system(update_timed_vulnerabilities_system.system())
                .with_system(update_vulnerability_factor_system.system())
                .with_system(lockpicking_system.system().after("exit_hiding"))
                .with_system(update_booled_vulnerabilities_system.system()),
        )
        .add_system_set(
            SystemSet::on_update(GameState::PlayerSleepingState)
                .with_system(update_timed_vulnerabilities_system.system())
                .with_system(update_vulnerability_factor_system.system())
                .with_system(update_booled_vulnerabilities_system.system()),
        );
    }
}

#[derive(Deserialize, Hash, Clone, Debug, PartialEq, Eq)]
pub enum TimedVulnerabilityType {
    ConsoleDoorLeftOpen,
}

#[derive(Deserialize, Hash, Clone, Debug, PartialEq, Eq)]
pub enum BoolVulnerabilityType {
    BedDoorLeftOpen,
    PeeDoorLeftOpen,
    TooManyRageQuit,
    TicTacToeLosing,
    LabyrinthLosing,
    LabyrinthWinning,
}

#[derive(Debug)]
pub struct VulnerabilityResource {
    pub vulnerability_per_frame: f32,
    pub timed_vulnerabilities: HashMap<TimedVulnerabilityType, Timer>,
    pub bool_vulnerabilities: HashMap<BoolVulnerabilityType, bool>,
    pub at_door: AtDoorType,
    pub vulnerability_factor: f32,
    pub lockpick_timer: Timer,
    pub lockpicking_progress_timer: Timer,
    pub lockpicking_audio_timer: Timer,
    pub lockpicking_status: LockpickingStatus,
    pub lockpicking_search_timer: Timer,
    pub is_hiding: bool,
    pub enemies: Vec<String>, // append enemies made in game to this
}

#[derive(Debug)]
pub enum LockpickingStatus {
    None,
    Lockpicking,
    SearchingRoom,
}

#[derive(Debug)]
pub enum AtDoorType {
    None,
    DeliveryPerson,
    Npc,
}

#[derive(Debug)]
pub struct VulnerabilityData {
    pub vulnerability: f32,
    pub game_over_threshold: f32,
}

pub fn update_vulnerability_factor_system(
    mut vulnerability_resource: ResMut<VulnerabilityResource>,
    day_cycle_resource: Res<DayCycleResource>,
    npcs_resource: Res<NPCsResource>,
) {
    let time_of_day_factor = (1.0
        - ((2.0 * PI * day_cycle_resource.day_timer.elapsed_secs())
            / (2.0 * day_cycle_resource.day_length))
            .sin())
        * (1.0 - DIFFICULTY)
        + DIFFICULTY;
    let enemies_factor =
        vulnerability_resource.enemies.len() as f32 / npcs_resource.npcs.len() as f32;
    vulnerability_resource.vulnerability_factor = time_of_day_factor * enemies_factor;
}

pub fn update_timed_vulnerabilities_system(
    mut commands: Commands,
    interactables_query: Query<&InteractableComponent>,
    mut vulnerability_resource: ResMut<VulnerabilityResource>,
    mut app_state: ResMut<State<GameState>>,
    mut texture_atlases: ResMut<Assets<TextureAtlas>>,
    time: Res<Time>,
    asset_server: Res<AssetServer>,
    audio: Res<Audio>,
    mut go_data: ResMut<GameOverData>,
) {
    let number_of_enemies = vulnerability_resource.enemies.len();
    for (v_type, v_timer) in vulnerability_resource.timed_vulnerabilities.iter_mut() {
        match v_type {
            TimedVulnerabilityType::ConsoleDoorLeftOpen => {
                for interactable_component in interactables_query.iter() {
                    if app_state.current() == &GameState::ConsoleOpenedState
                        && InteractableType::OpenDoor == interactable_component.interactable_type
                        && number_of_enemies > 0
                    {
                        v_timer.tick(time.delta());
                    } else if app_state.current() == &GameState::MainGame
                        && InteractableType::ClosedDoor == interactable_component.interactable_type
                    {
                        v_timer.reset();
                    }
                }

                if v_timer.just_finished() {
                    v_timer.reset();
                    v_timer.pause();
                    spawn_npc(
                        "textures/npcs/npc_1_forward_spritesheet.png",
                        Vec2::new(-215.0, -72.0),
                        &mut commands,
                        &asset_server,
                        &mut texture_atlases,
                    );
                    if app_state.current() == &GameState::ConsoleOpenedState {
                        go_data.reason = Some(GameOverReason::DoorLeftOpen);
                        app_state.set(GameState::GameOverState).unwrap();
                        #[cfg(debug_assertions)]
                        info!("Console closed");
                    }
                    audio.play(asset_server.load("audio/dramatic_scare.mp3"));
                }
            }
        }
    }
}

pub fn update_booled_vulnerabilities_system(
    vuln_res: Res<VulnerabilityResource>,
    mut app_state: ResMut<State<GameState>>,
    mut go_data: ResMut<GameOverData>,
) {
    if *vuln_res
        .bool_vulnerabilities
        .get(&BoolVulnerabilityType::TooManyRageQuit)
        .unwrap()
        && app_state.current() == &GameState::ConsoleOpenedState
    {
        go_data.reason = Some(GameOverReason::TooManyRageQuit);
        app_state.set(GameState::GameOverState).unwrap();
    }

    if *vuln_res
        .bool_vulnerabilities
        .get(&BoolVulnerabilityType::TicTacToeLosing)
        .unwrap()
        && app_state.current() == &GameState::ConsoleOpenedState
    {
        go_data.reason = Some(GameOverReason::TicTacToeLosing);
        app_state.set(GameState::GameOverState).unwrap();
    }

    if *vuln_res
        .bool_vulnerabilities
        .get(&BoolVulnerabilityType::LabyrinthLosing)
        .unwrap()
        && app_state.current() == &GameState::ConsoleOpenedState
    {
        go_data.reason = Some(GameOverReason::LabyrinthLosing);
        app_state.set(GameState::GameOverState).unwrap();
    }

    if *vuln_res
        .bool_vulnerabilities
        .get(&BoolVulnerabilityType::LabyrinthWinning)
        .unwrap()
        && app_state.current() == &GameState::MainGame
    {
        go_data.reason = Some(GameOverReason::LabyrinthWinning);
        app_state.set(GameState::GameOverState).unwrap();
    }
}

pub fn spawn_npc(
    npc_sprite_path: &str,
    position: Vec2,
    commands: &mut Commands,
    asset_server: &AssetServer,
    texture_atlases: &mut Assets<TextureAtlas>,
) {
    let texture_handle = asset_server.load(npc_sprite_path);
    let texture_atlas = TextureAtlas::from_grid(texture_handle, Vec2::new(32.0, 46.0), 6, 1);
    let texture_atlas_handle = texture_atlases.add(texture_atlas);

    let sprite_transform = Transform {
        translation: Vec3::new(position.x, position.y, NPC_Z),
        scale: Vec3::new(PLAYER_SPRITE_SCALE, PLAYER_SPRITE_SCALE, 0.0),
        ..Default::default()
    };

    commands
        .spawn()
        .insert(BasicAnimationComponent)
        .insert(Timer::from_seconds(NPC_FRAME_TIME, true))
        .insert_bundle(SpriteSheetBundle {
            texture_atlas: texture_atlas_handle,
            transform: sprite_transform,
            ..Default::default()
        })
        .insert(Name::new("NPC"));
}

//pub struct LockPick

pub fn lockpicking_system(
    mut commands: Commands,
    pizza_delivery_resource: Res<PizzaDeliveryResource>,
    mut vulnerability_resource: ResMut<VulnerabilityResource>,
    interactables_resource: Res<InteractablesResource>,
    time: Res<Time>,
    interactable_component_query: Query<&InteractableComponent>,
    interactable_query: Query<(Entity, &InteractableComponent)>,
    hallway_cover_query: Query<Entity, With<HallwayCoverComponent>>,
    mut texture_atlases: ResMut<Assets<TextureAtlas>>,
    asset_server: Res<AssetServer>,
    audio: Res<Audio>,
    mut go_data: ResMut<GameOverData>,
    mut app_state: ResMut<State<GameState>>,
    mut materials: ResMut<Assets<ColorMaterial>>,
) {
    if let PizzaDeliveryStatus::Ordered | PizzaDeliveryStatus::AtDoor =
        pizza_delivery_resource.status
    {
        if let LockpickingStatus::Lockpicking = vulnerability_resource.lockpicking_status {
            info!("Lockpicking cancelled.");
            vulnerability_resource.lockpicking_status = LockpickingStatus::None;
            vulnerability_resource.at_door = AtDoorType::None;
            vulnerability_resource
                .lockpicking_progress_timer
                .set_elapsed(Duration::from_secs_f32(0.0));
        }
    }
    let mut is_door_open = false;
    for ineractable_component in interactable_component_query.iter() {
        if let InteractableType::OpenDoor = ineractable_component.interactable_type {
            is_door_open = true;
        }
    }

    match vulnerability_resource.lockpicking_status {
        LockpickingStatus::None => {
            if let PizzaDeliveryStatus::Delivered | PizzaDeliveryStatus::Unordered =
                pizza_delivery_resource.status
            {
                if !is_door_open {
                    vulnerability_resource.lockpick_timer.tick(time.delta());

                    if vulnerability_resource.lockpick_timer.just_finished()
                        && rand::thread_rng().gen::<f32>()
                            * vulnerability_resource.vulnerability_factor
                            > 0.1
                    {
                        // start lockpicking event
                        #[cfg(debug_assertions)]
                        info!("NPC lockpicking the door.");
                        vulnerability_resource.at_door = AtDoorType::Npc;
                        vulnerability_resource.lockpicking_status = LockpickingStatus::Lockpicking;
                        audio.play(asset_server.load("audio/lockpicking.mp3"));
                    }
                }
            }
        }
        LockpickingStatus::Lockpicking => {
            vulnerability_resource
                .lockpicking_progress_timer
                .tick(time.delta());

            vulnerability_resource
                .lockpicking_audio_timer
                .tick(time.delta());

            if vulnerability_resource
                .lockpicking_audio_timer
                .just_finished()
            {
                audio.play(asset_server.load("audio/lockpicking.mp3"));
            }

            if vulnerability_resource
                .lockpicking_progress_timer
                .just_finished()
            {
                vulnerability_resource.lockpicking_status = LockpickingStatus::None;
                #[cfg(debug_assertions)]
                info!("NPC lockpicked the door.");
                // open the door
                #[cfg(debug_assertions)]
                info!("Door opened");
                // despawn the closed door
                for (interactable_entity, interactable_component) in interactable_query.iter() {
                    if let InteractableType::ClosedDoor = interactable_component.interactable_type {
                        commands.entity(interactable_entity).despawn();
                        despawn_hallway_cover(&mut commands, &hallway_cover_query);
                        audio.play(asset_server.load("audio/door_opening.mp3"));
                    }
                }

                // spawn an open door
                spawn_open_door(&mut commands, &interactables_resource);
                // player is hiding and npc "searches the room"
                // or
                // spawn npc and game over
                if vulnerability_resource.is_hiding {
                    vulnerability_resource.lockpicking_status = LockpickingStatus::SearchingRoom;
                } else {
                    spawn_npc(
                        "textures/npcs/npc_1_forward_spritesheet.png",
                        Vec2::new(-222.0, 53.0),
                        &mut commands,
                        &asset_server,
                        &mut texture_atlases,
                    );
                    if app_state.current() == &GameState::MainGame
                        || app_state.current() == &GameState::ConsoleOpenedState
                        || app_state.current() == &GameState::PeepholeOpenedState
                    {
                        go_data.reason = Some(GameOverReason::LetThemIn);
                        app_state.set(GameState::GameOverState).unwrap();
                    }
                    audio.play(asset_server.load("audio/dramatic_scare.mp3"));
                }
            }
        }
        LockpickingStatus::SearchingRoom => {
            vulnerability_resource
                .lockpicking_search_timer
                .tick(time.delta());

            if !vulnerability_resource.is_hiding {
                vulnerability_resource.lockpicking_status = LockpickingStatus::None;
                vulnerability_resource.at_door = AtDoorType::None;
                // game over
                spawn_npc(
                    "textures/npcs/npc_1_right_spritesheet.png",
                    Vec2::new(-18.0, 20.0),
                    &mut commands,
                    &asset_server,
                    &mut texture_atlases,
                );
                println!("{:?}", app_state.current());
                if app_state.current() == &GameState::MainGame
                    || app_state.current() == &GameState::PlayerHidingState
                {
                    go_data.reason = Some(GameOverReason::LetThemIn);
                    app_state.overwrite_push(GameState::GameOverState).unwrap();
                }
                audio.play(asset_server.load("audio/dramatic_scare.mp3"));
            }

            if vulnerability_resource
                .lockpicking_search_timer
                .just_finished()
            {
                vulnerability_resource.lockpicking_status = LockpickingStatus::None;
                vulnerability_resource.at_door = AtDoorType::None;
                info!("npc done searching");
                // close the door
                for (interactable_entity, interactable_component) in interactable_query.iter() {
                    if let InteractableType::OpenDoor = interactable_component.interactable_type {
                        commands.entity(interactable_entity).despawn();
                        spawn_hallway_cover(&mut commands, &asset_server, &mut materials);
                        audio.play(asset_server.load("audio/door_shutting.mp3"));
                    }
                }

                // spawn an open doo
                spawn_closed_door(&mut commands, &interactables_resource);
            }
        }
    }
}
