use crate::apartment::{
    BasicAnimationComponent, InteractableComponent, InteractableType, NPC_Z, PLAYER_SPRITE_SCALE,
};
use crate::states::GameState;
use bevy::prelude::*;
use ron::de::from_bytes;
use serde::Deserialize;
use std::collections::HashMap;

pub const NPC_FRAME_TIME: f32 = 0.4;

pub struct VulnerabilityPlugin;

impl Plugin for VulnerabilityPlugin {
    fn build(&self, app: &mut AppBuilder) {
        let mut timed_vulnerabilities: HashMap<VulnerabilityType, Timer> = HashMap::new();
        timed_vulnerabilities.insert(
            VulnerabilityType::DoorLeftOpen,
            Timer::from_seconds(8.0, false),
        );
        app.insert_resource(VulnerabilityResource {
            timed_vulnerabilities,
            vulnerability_per_frame: 1.0,
        })
        .add_system(update_timed_vulnerabilities_system.system());
    }
}

#[derive(Deserialize, Hash, Clone, Debug, PartialEq, Eq)]
pub enum VulnerabilityType {
    DoorLeftOpen,
}

#[derive(Debug)]
pub struct VulnerabilityResource {
    vulnerability_per_frame: f32,
    timed_vulnerabilities: HashMap<VulnerabilityType, Timer>,
}

#[derive(Debug)]
pub struct VulnerabilityData {
    pub vulnerability: f32,
    pub game_over_threshold: f32,
}

pub fn update_timed_vulnerabilities_system(
    mut commands: Commands,
    interactables_query: Query<&InteractableComponent>,
    mut vulnerability_resource: ResMut<VulnerabilityResource>,
    mut app_state: ResMut<State<GameState>>,
    mut texture_atlases: ResMut<Assets<TextureAtlas>>,
    time: Res<Time>,
    asset_server: Res<AssetServer>,
    audio: Res<Audio>,
) {
    for (v_type, v_timer) in vulnerability_resource.timed_vulnerabilities.iter_mut() {
        match v_type {
            VulnerabilityType::DoorLeftOpen => {
                for interactable_component in interactables_query.iter() {
                    if app_state.current() == &GameState::ConsoleOpenedState
                        && InteractableType::OpenDoor == interactable_component.interactable_type
                    {
                        v_timer.tick(time.delta());
                    } else if app_state.current() == &GameState::MainGame
                        && InteractableType::ClosedDoor == interactable_component.interactable_type
                    {
                        v_timer.reset();
                    }
                }
            }
        }

        if v_timer.just_finished() {
            v_timer.reset();
            v_timer.pause();
            spawn_npc(
                Vec2::new(-215.0, -72.0),
                &mut commands,
                &asset_server,
                &mut texture_atlases,
            );
            if app_state.current() == &GameState::ConsoleOpenedState {
                app_state.set(GameState::MainGame).unwrap();
                info!("Console closed");
            }
            audio.play(asset_server.load("audio/dramatic_scare.mp3"));
        }
    }
}

pub fn spawn_npc(
    position: Vec2,
    commands: &mut Commands,
    asset_server: &AssetServer,
    texture_atlases: &mut Assets<TextureAtlas>,
) {
    //let texture_handle = asset_server.load("textures/npcs/npc_1.png");

    let texture_handle = asset_server.load("textures/npcs/npc_1_spritesheet.png");
    let texture_atlas = TextureAtlas::from_grid(texture_handle, Vec2::new(32.0, 46.0), 6, 1);
    let texture_atlas_handle = texture_atlases.add(texture_atlas);

    let sprite_transform = Transform {
        translation: Vec3::new(position.x, position.y, NPC_Z),
        scale: Vec3::new(PLAYER_SPRITE_SCALE, PLAYER_SPRITE_SCALE, 0.0),
        ..Default::default()
    };

    commands
        .spawn()
        .insert(BasicAnimationComponent)
        .insert(Timer::from_seconds(NPC_FRAME_TIME, true))
        .insert_bundle(SpriteSheetBundle {
            texture_atlas: texture_atlas_handle,
            transform: sprite_transform,
            ..Default::default()
        })
        .insert(Name::new("NPC"));
}
